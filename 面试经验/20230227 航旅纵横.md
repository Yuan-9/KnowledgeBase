# 20230227 航旅纵横一面

**类的非静态方法中是否能有静态变量**

在类的非静态方法中不能声明静态变量。静态变量属于类的成员变量，而非静态方法属于对象的成员方法。在类的非静态方法中声明静态变量会导致语法错误，因为静态变量是类的属性，而非静态方法是对象的属性，不能将类的属性声明在对象的属性中。

在一个类的非静态方法中可以使用静态变量。静态变量属于类的成员变量，而非静态方法属于对象的成员方法，两者之间没有直接关系。因此，在非静态方法中可以使用静态变量，也可以修改静态变量的值。

**下列哪一种叙述是正确的（）关键字：接口方法**

​	**A.abstract修饰符可修饰字段、方法和类**

​	**B.抽象方法的body部分必须用一对大括号包住**

​	**C声明抽象方法，大括号可有可无**

​	**D声明抽象方法不可写出大括号**

正确答案是 D。在声明抽象方法时，不能写出方法体（即大括号）。抽象方法是没有具体实现的方法，只有方法签名，因此不需要包含方法体。

A选项是错误的，`abstract`修饰符只能修饰方法和类，不能修饰字段。

B选项是错误的，抽象方法是没有具体实现的方法，因此不能有方法体，即不能用一对大括号包围。

C选项是错误的，抽象方法只有方法签名，不包含具体实现，因此不能有方法体。

**下列哪种说法是正确的（）关键字：private**

​	**A.实例方法可直接调用超类的实例方法**

​	**B.实例方法可直接调用超类的类方法**

​	**C.实例方法可直接调用其他类的实例方法**

​	**D.实例方法可直接调用本类的类方法**



**子类重写规则：返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类**



**冒泡排序及快速排序**



**JDK1.8 swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上？**



**一个5升水桶一个3升水桶怎么计算出4升水？**



**表A字段m，n，×，y。其中m，n为number类型，x为字符类型，y为字符类型，MYSQL数据库**

**（1）更新表A中m值在5到15之间的数据，将n改为6，y改为系统当前日期（sysdate0）**

**（2）假设×为员工姓名，y为员工的生日，查询出生日相同人的×**

(1) 更新表 A 中 m 值在 5 到 15 之间的数据，将 n 改为 6，y 改为系统当前日期（sysdate）的 SQL 语句如下：

```sql
UPDATE A SET n = 6, y = sysdate() WHERE m >= 5 AND m <= 15;
```

该语句使用 `UPDATE` 命令更新表 A 中 m 值在 5 到 15 之间的数据，将 n 改为 6，y 改为系统当前日期。`sysdate()` 是 MySQL 中获取系统当前日期时间的函数。

(2) 查询出生日相同人的 × 的 SQL 语句如下：

```sql
SELECT x FROM A WHERE y IN (
    SELECT y FROM A GROUP BY y HAVING COUNT(*) > 1
);
```

该语句使用 `SELECT` 命令查询表 A 中生日相同人的 x 值。内层查询使用 `GROUP BY` 和 `HAVING` 条件查询出生日相同的 y 值，外层查询使用 `IN` 条件查询出 y 值在内层查询结果中的 x 值。

**什么是面向对象，解释封装继承多态**

面向对象编程（Object Oriented Programming，OOP）是一种编程思想和方法论，它把程序中的数据和对数据的操作组织成一个对象，并封装了对象的状态和行为。在面向对象编程中，通过对象之间的交互来实现程序的功能。

封装（Encapsulation）是面向对象编程中的一种特性，它将对象的状态和行为封装在一起，对外部隐藏对象的内部实现细节，只向外提供公共的接口。这样可以保证对象的内部状态不被外部直接修改，从而提高了代码的安全性和可维护性。

继承（Inheritance）是面向对象编程中的另一种特性，它允许一个类继承另一个类的特性和行为。子类可以继承父类的属性和方法，并且可以在此基础上扩展和修改父类的功能。这样可以提高代码的复用性和可扩展性。

多态（Polymorphism）是面向对象编程中的第三个特性，它允许一个变量或者函数调用能够指向不同的对象，以实现不同的行为。多态性可以通过继承和接口实现，它可以让程序更加灵活、可扩展和易维护。

**重写和重载的区别**

重写指的是在子类中重新定义父类的方法，使得子类可以对父类中的方法进行修改或者扩展。重写要求方法名、参数列表和返回类型完全相同，而方法体不同。重写可以使用 `@Override` 注解来标注，可以提高代码的可读性和可维护性。

重载指的是在同一个类中，定义多个名称相同但参数列表不同的方法。重载方法可以根据传入的参数类型和数量不同，执行不同的操作。重载方法的方法名必须相同，但参数列表不同。重载方法可以有不同的返回类型。

重写和重载的区别在于：

- 重写是子类对父类中的方法进行重新定义，方法名、参数列表和返回类型必须相同，而方法体不同。
- 重载是在同一个类中，定义多个名称相同但参数列表不同的方法，可以根据传入的参数类型和数量的不同执行不同的操作。
- 重写可以实现多态，而重载不能。
- 重写可以覆盖父类中的方法，而重载不会覆盖父类中的方法。
- 重载方法可以有不同的返回类型，但不能只有返回类型不同而参数列表相同。

**关于JVM有什么了解**

JVM是Java Virtual Machine（Java虚拟机）的缩写，它是Java的核心组成部分之一，是Java的跨平台特性的基础。

JVM的主要作用是将Java字节码解释或编译成机器码，以实现Java的跨平台特性。Java源代码经过编译器编译后，生成的是Java字节码文件，这些字节码文件可以在任何支持Java虚拟机的平台上运行。JVM中包含了许多重要的组件，如类加载器、解释器、即时编译器、垃圾回收器等，这些组件共同协作来实现Java程序的运行。

JVM负责管理内存、处理异常、执行线程等重要任务，保证Java程序的运行稳定和高效。JVM还提供了一些用于调试和优化Java程序的工具，如jconsole、jvisualvm、jmap、jstack等。通过这些工具，我们可以深入了解Java程序的运行状态，帮助我们发现和解决程序中的性能问题。

总的来说，JVM是Java语言的核心组成部分，它提供了Java的跨平台特性和重要的运行时支持，对Java程序的性能和稳定性起着至关重要的作用。

**垃圾回收有什么了解**

Java 虚拟机（JVM）的垃圾回收机制是自动管理 Java 程序运行时堆内存分配和回收的一种机制。在 Java 中，程序员不需要显式地去管理内存，而是由 JVM 来进行垃圾回收。JVM 会定期扫描程序的内存，找出不再使用的对象，并将它们释放掉，以便将内存空间重新分配给其他对象使用。

JVM 的垃圾回收机制主要有以下几个特点：

1. 自动化：JVM 会自动进行垃圾回收，程序员不需要显式地去管理内存。
2. 不可控性：垃圾回收的时间和机制都由 JVM 内部控制，程序员无法对其进行干预。
3. 可靠性：JVM 会根据需要进行垃圾回收，并且保证回收的对象不会再被程序引用，从而保证了程序的可靠性。
4. 开销大：JVM 进行垃圾回收的时候需要占用一定的 CPU 和内存资源，从而会影响程序的性能。

JVM 的垃圾回收机制有很多种实现方式，包括标记清除、复制算法、标记整理和分代收集等。每种实现方式都有其适用的场景和优缺点，程序员可以根据具体的需求和场景选择合适的方式来进行垃圾回收。为了提高程序的性能，程序员可以使用一些技巧，如避免创建过多的临时对象、及时释放不需要的对象等，从而减少垃圾回收的开销。

**Mybatis二级缓存？**

Mybatis 的二级缓存是一种将 SQL 查询结果缓存在内存中的机制。它的作用是提高查询效率，减少数据库的访问次数。

二级缓存是指将数据缓存到一个共享的缓存区域，使多个 SqlSession 共享缓存区域中的数据，从而减少数据库的查询次数，提高系统的性能。二级缓存可以在多个 SqlSession 之间共享，但是它是基于 Mapper 命名空间（namespace）级别的，不同的 Mapper 命名空间中的数据互不影响。

需要注意的是，二级缓存中缓存的数据是序列化后的字节流，因此需要确保对象可序列化。此外，二级缓存在实际应用中还需要注意一些细节，例如在进行数据修改时需要清空缓存、不能缓存过大的数据等。因此，在使用二级缓存时需要结合具体的业务场景和需求进行调整和优化。

**MySQL两个引擎：InnoDB和MyISAM？**

InnoDB 引擎是 MySQL 的默认存储引擎，它支持事务、行级锁、外键约束等高级特性，适合于高并发和高可靠性的应用场景。InnoDB 引擎在执行 SELECT 查询时使用了 MVCC（多版本并发控制）机制，可以在不锁定整个表的情况下实现行级锁，从而提高了并发性能。另外，InnoDB 引擎还支持数据的备份和恢复，可以在数据损坏时快速恢复数据。

MyISAM 引擎是 MySQL 中另一种常用的存储引擎，它不支持事务和行级锁，但是对于查询性能比较高的应用场景，可以使用 MyISAM 引擎来提高查询性能。MyISAM 引擎在执行 SELECT 查询时使用了表级锁，因此并发性能较差，但是由于不需要支持事务，因此可以减少系统的开销，提高系统的性能。MyISAM 引擎还支持全文索引，可以在搜索和排序方面提供一定的性能优势。

**Java线程，线程池，线程池参数？**

Java 中的线程是一种轻量级的并发执行单元，它可以在一个程序中同时执行多个任务。在 Java 中，线程的创建和销毁非常消耗资源，因此使用线程池来管理线程可以提高系统的性能和资源利用率。

Java 中的线程池是一种线程池框架，它提供了一种管理线程的机制，可以将线程的创建、销毁和复用等操作交给线程池来处理。使用线程池可以避免线程创建和销毁的开销，提高线程的复用率和系统的性能。

Java 线程池的常用参数包括：

1. `corePoolSize`：线程池中的核心线程数，当提交任务时，如果线程池中的线程数小于核心线程数，则创建新的线程执行任务，否则将任务加入任务队列。
2. `maximumPoolSize`：线程池中的最大线程数，当任务队列已满时，创建新的线程执行任务，直到达到最大线程数为止。
3. `keepAliveTime`：线程的存活时间，当线程池中的线程数大于核心线程数时，空闲线程的存活时间。当空闲线程的存活时间超过指定时间时，将被销毁。
4. `workQueue`：任务队列，用于存储等待执行的任务。线程池中的线程从任务队列中取出任务执行。
5. `threadFactory`：线程工厂，用于创建新的线程。
6. `handler`：拒绝策略，当任务队列已满且线程池中的线程数已达到最大线程数时，新提交的任务将被拒绝执行，拒绝策略可以决定如何处理这些任务。

在使用线程池时，需要根据具体的应用场景和需求来设置线程池的参数，例如核心线程数、最大线程数、任务队列的大小和拒绝策略等。适当地设置线程池的参数可以提高系统的性能和稳定性，同时避免出现线程池满或者空闲线程过多等问题。