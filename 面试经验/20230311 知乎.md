# 23230311 知乎一面

**技术派项目中主要做了哪些工作**

我在其中实现了社区首页、文章发布、文章详情、个人中心等模块。

**Spring和Spring Boot的区别？**

Spring是一个Java企业级开发框架，提供了许多用于构建企业级应用的功能，如依赖注入、面向切面编程、数据访问、Web开发、消息队列等等。Spring框架非常强大，但是使用起来需要配置大量的XML文件，配置繁琐，学习曲线较陡峭。

Spring Boot是基于Spring框架的，它提供了更加简单、快速的方式来构建基于Spring的应用。Spring Boot自动配置了Spring的各种组件，包括MVC、JPA、数据源、安全认证等等，用户可以通过简单的配置即可快速构建一个可运行的Web应用。Spring Boot的特点是约定大于配置，减少了Spring应用的开发、配置和部署的复杂度。

**吾评项目中主要做了哪些工作？**

**MVVM和MVC的区别？**

**描述MVVM是怎么工作的**

**做技术派项目的契机？**

**ArrayList和Linkedlist的区别？为什么？**

ArrayList是基于数组实现的，它的底层是一个动态的数组，当数组满了需要扩容时，ArrayList会创建一个新的数组，并将原来数组中的元素复制到新的数组中。因为ArrayList是基于数组实现的，所以它的随机访问速度非常快，但是插入、删除操作的效率比较低，因为需要移动其他元素。

LinkedList是基于双向链表实现的，它的每个节点都包含了前后两个指针，节点之间通过指针相连。因为LinkedList是基于链表实现的，所以插入、删除操作的效率比较高，但是随机访问速度比较低，因为需要遍历链表来查找对应的元素。

**栈和队列的区别？平时有用到过吗？**

**如何用栈来模拟队列？**

**计算6&5和6|5**

**了解JVM吗？**

JVM是Java Virtual Machine（Java虚拟机）的缩写，它是Java的核心组成部分之一，是Java的跨平台特性的基础。

JVM的主要作用是将Java字节码解释或编译成机器码，以实现Java的跨平台特性。Java源代码经过编译器编译后，生成的是Java字节码文件，这些字节码文件可以在任何支持Java虚拟机的平台上运行。JVM中包含了许多重要的组件，如类加载器、解释器、即时编译器、垃圾回收器等，这些组件共同协作来实现Java程序的运行。

JVM负责管理内存、处理异常、执行线程等重要任务，保证Java程序的运行稳定和高效。JVM还提供了一些用于调试和优化Java程序的工具，如jconsole、jvisualvm、jmap、jstack等。通过这些工具，我们可以深入了解Java程序的运行状态，帮助我们发现和解决程序中的性能问题。

总的来说，JVM是Java语言的核心组成部分，它提供了Java的跨平台特性和重要的运行时支持，对Java程序的性能和稳定性起着至关重要的作用。

**栈内存和堆内存的区别？**

在Java中，内存被分为两种不同的存储区域：栈内存和堆内存。

栈内存是一种线程私有的内存区域，它用来存储线程中的基本类型变量和对象的引用。栈内存的特点是空间大小固定，内存管理由系统自动进行，栈中的变量会随着方法的执行结束而自动释放。

堆内存是一种线程共享的内存区域，用来存储所有的Java对象。堆内存的特点是空间大小不固定，内存的分配和释放由Java程序员手动控制。Java中的new操作符就是在堆内存中分配对象的空间。

栈内存和堆内存之间还有一个重要的区别，就是变量存储的内容不同。在栈内存中存储的是基本类型的值和对象的引用，而对象的实际数据则存储在堆内存中。

**抽象类和接口的区别？**

抽象类是一种特殊的类，它用关键字abstract来定义。抽象类不能被实例化，只能被继承。抽象类中可以定义抽象方法，抽象方法是没有实现的方法，必须在具体子类中实现。抽象类中也可以定义非抽象方法，非抽象方法是有实现的方法，子类可以继承或重写这些方法。抽象类的主要作用是作为其他类的父类，用来定义公共的属性和方法。

接口是一种特殊的类，它用关键字interface来定义。接口中只能定义常量和方法，没有实现的方法。接口不能被实例化，只能被实现。类通过实现接口的方式来使用接口中定义的方法。接口的主要作用是为多个类提供一个公共的方法规范，实现类必须实现接口中定义的所有方法。

抽象类和接口之间的区别在于：

1. 抽象类可以有构造方法，接口不能有构造方法；
2. 抽象类中可以有非抽象方法，接口中只能有抽象方法；
3. 子类继承抽象类时，必须实现父类中的所有抽象方法，子类实现接口时，必须实现接口中的所有方法；
4. 一个类只能继承一个抽象类，但是可以实现多个接口。

因此，我们通常在以下情况下使用抽象类：

1. 想要定义一些共性的方法和属性，并希望子类对这些方法和属性进行具体实现；
2. 有些方法需要有默认实现，但是也有些方法必须在子类中进行实现；
3. 想要限制子类的类型，只允许某些子类继承该类。

而在以下情况下使用接口：

1. 想要定义一个方法规范，不关心具体实现方式；
2. 希望不同的类实现同样的方法，以实现某种功能；
3. 希望在不同的类之间实现一种多态行为。

**了解过Java泛型吗？**

Java泛型是Java语言中的一个重要特性，用来提高代码的类型安全性和可读性。

Java泛型实际上是一个参数化类型的概念。它可以让我们定义一个通用的类型，在使用时再指定具体的数据类型。通过泛型，我们可以在编译时检查代码的类型安全性，并在运行时避免类型转换错误。

在Java中，泛型主要用于以下两种情况：

1. 定义泛型类：通过在类定义中使用泛型来定义一个通用的类型；
2. 定义泛型方法：通过在方法定义中使用泛型来定义一个通用的方法。

Java泛型中主要的概念包括：

1. 泛型类：使用泛型来定义类的类型；
2. 泛型方法：使用泛型来定义方法的类型；
3. 泛型接口：使用泛型来定义接口的类型；
4. 泛型通配符：用来表示泛型类型的上限或下限；
5. 类型擦除：Java泛型是通过类型擦除来实现的，编译器在编译时会将泛型类型擦除为原始类型。

在使用Java泛型时，需要注意以下几点：

1. 泛型只在编译时有效，在运行时会被擦除；
2. 泛型类型参数不能使用基本类型，只能使用对象类型；
3. 泛型类型参数只能使用引用类型，不能使用基本类型；
4. 泛型类型参数可以有多个，用逗号隔开；
5. 泛型类型参数的上限可以使用 extends 关键字来指定，下限可以使用 super 关键字来指定；
6. 在泛型类中可以使用泛型类型参数来定义成员变量、成员方法和构造方法；
7. 在泛型方法中可以使用泛型类型参数来定义方法的参数和返回值。

**进程和线程的区别？**

进程是程序在操作系统中的一次执行过程，是系统资源分配和调度的基本单位，它包括了程序代码、数据、堆栈等信息，具有独立的内存空间和系统资源，各个进程之间相互独立，互不干扰。

线程是进程中的一个执行单元，是系统调度的最小单位，一个进程可以包含多个线程，共享进程的资源，但是每个线程都有自己的栈空间和程序计数器。线程之间的切换比进程之间的切换更快，因为它们共享了进程的内存空间和系统资源，而不需要像进程那样进行资源的重新分配和初始化。

总的来说，进程和线程都是并发执行的基本单位，但是进程之间相互独立，资源隔离，线程则共享进程的资源，切换更快，但是需要遵守一定的线程同步和互斥规则，以避免数据竞争和死锁等问题。

**进程有自己独立的内存空间吗？线程有吗？**

进程和线程都有自己独立的内存空间。

在操作系统中，每个进程都有自己的地址空间，包括代码、数据和堆栈等区域。不同进程之间的地址空间是独立的，一个进程无法访问另一个进程的地址空间。这种独立的内存空间保证了每个进程之间的相互隔离，提高了系统的稳定性和安全性。

类似地，每个线程也有自己的堆栈空间和寄存器。不同线程之间共享进程的地址空间，但是每个线程拥有独立的堆栈空间和寄存器，线程之间的相互访问是受到限制的。这种独立的内存空间保证了线程之间的相互隔离，提高了多线程并发执行时的安全性。

总之，进程和线程都有自己独立的内存空间，但是不同进程之间的内存空间是完全隔离的，而不同线程之间的内存空间是共享部分地址空间的。

**可以从哪些方面解决线程安全的问题？**

1. 使用线程安全的数据结构：例如 ConcurrentHashMap、CopyOnWriteArrayList 等，这些数据结构在实现上考虑了并发访问的情况，可以避免线程安全问题。
2. 同步代码块和同步方法：使用 synchronized 关键字修饰的代码块和方法可以保证同一时刻只有一个线程访问，从而避免多个线程同时访问导致的竞态条件。
3. 使用锁：Java中提供了多种锁的机制，例如 ReentrantLock、ReadWriteLock 等，使用锁可以控制多个线程对共享资源的访问，从而避免线程安全问题。
4. 使用 volatile 关键字：volatile 关键字可以保证变量的可见性，即每个线程对变量的修改都能及时被其他线程看到，从而避免由于多线程修改同一个变量导致的数据不一致问题。
5. 使用原子类：Java中提供了多种原子类，例如 AtomicInteger、AtomicLong 等，这些类可以保证对变量的操作是原子性的，从而避免多个线程同时修改同一个变量导致的线程安全问题。

**Java中有哪些方式可以加锁？**

1. synchronized关键字：synchronized是Java中内置的锁机制，可以对代码块或方法进行加锁，从而保证同一时刻只有一个线程访问。
2. ReentrantLock：ReentrantLock是Java中提供的可重入锁机制，可以通过lock()方法和unlock()方法手动加锁和解锁，也可以设置为公平锁或非公平锁。
3. ReadWriteLock：ReadWriteLock是Java中提供的读写锁机制，可以在读多写少的场景下提高程序的并发性能。
4. Semaphore：Semaphore是Java中提供的信号量机制，可以控制同一时刻访问某个资源的线程数量。
5. CountDownLatch：CountDownLatch是Java中提供的倒计时计数器机制，可以等待多个线程完成某个操作后再继续执行。
6. CyclicBarrier：CyclicBarrier是Java中提供的循环屏障机制，可以等待多个线程到达某个屏障点后再继续执行。

**HTTP和HTTPS的区别？**

HTTP（Hypertext Transfer Protocol）和HTTPS（HTTP Secure）是两种不同的协议。它们主要的区别在于安全性和加密方式。

HTTP是一种明文协议，数据在传输过程中不加密，因此容易被第三方截获、篡改或窃取。HTTP协议在传输数据的过程中，只负责数据的传输，并不关心数据的安全性，因此存在一定的安全风险。

HTTPS是在HTTP基础上加入了SSL/TLS协议进行加密和认证，使数据在传输过程中得到了保护。HTTPS使用了公钥加密和私钥解密的方式，对传输的数据进行加密，可以有效地防止数据在传输过程中被篡改或者窃取。同时，HTTPS还提供了身份认证机制，确保通信双方的身份，防止中间人攻击。

在实际应用中，HTTP通常用于非敏感数据的传输，如一般的网页、图片、音频、视频等。而HTTPS通常用于传输敏感信息，如个人账号、密码、银行卡信息等。

总之，HTTP和HTTPS的主要区别在于安全性和加密方式。HTTPS是一种更加安全的协议，适用于传输敏感信息的场景。

**说一下HTTP的方法？**

1. GET方法：GET方法用于从服务器获取资源，请求的参数以查询字符串的形式附加在URL后面，例如：http://example.com/?name=value。GET方法的请求是幂等的，即对同一URL的多次请求结果相同，不会对服务器端的资源产生副作用。
2. POST方法：POST方法用于向服务器提交数据，请求的参数以表单数据的形式发送，例如：name=value&age=18。POST方法的请求不是幂等的，即对同一URL的多次请求可能会对服务器端的资源产生副作用，例如添加一条记录到数据库中。
3. PUT方法：PUT方法用于向服务器上传文件或者更新资源，请求的参数以请求体的形式发送，例如上传一个文件。PUT方法的请求是幂等的，即多次发送同一个请求不会对服务器端的资源产生影响。
4. DELETE方法：DELETE方法用于删除服务器上的资源，请求的参数以URL的形式发送，例如：http://example.com/delete/1。DELETE方法的请求是幂等的，即多次发送同一个请求的结果相同，不会对服务器端的资源产生影响。
5. HEAD方法：HEAD方法与GET方法类似，但是不返回实体的主体部分，只返回响应头信息，用于获取资源的元数据信息。
6. OPTIONS方法：OPTIONS方法用于获取服务器支持的HTTP请求方法和资源支持的MIME类型等信息。
7. TRACE方法：TRACE方法用于对客户端和服务器之间的请求和响应进行追踪和诊断。

**DNS的作用？**

DNS（Domain Name System，域名系统）是互联网中的一种命名系统，主要用于将域名转换为IP地址，从而实现计算机之间的通信。DNS的主要作用有以下几个方面：

1. 域名解析：DNS将域名转换为IP地址，使得用户可以通过域名来访问互联网上的各种资源。
2. 负载均衡：通过DNS服务器将请求分配到不同的服务器上，从而实现负载均衡。
3. 防止DNS劫持：通过使用DNSSEC等机制，可以有效地防止DNS劫持等安全问题。
4. 优化访问速度：通过DNS服务器的缓存机制，可以提高网站的访问速度。

**如何避免DNS被域名服务商解析出错？即避免DNS污染问题？**

DNS污染是一种常见的网络攻击，它会导致用户无法访问正确的网站，而被重定向到错误的网站。以下是一些可以帮助您避免DNS污染的方法：

1. 使用可靠的DNS服务：使用知名的、经过验证的DNS服务商，例如Google Public DNS或OpenDNS，可以减少DNS被污染的可能性。
2. 加密DNS：加密DNS可以帮助保护您的DNS查询免受中间人攻击或窃听。您可以使用DNS over HTTPS (DoH)或DNS over TLS (DoT)来加密DNS查询。
3. 更新系统和应用程序：及时更新您的操作系统和应用程序，以确保您的系统和应用程序中的DNS解析器不会受到已知的漏洞攻击。
4. 配置防火墙：在网络入口处配置防火墙可以帮助防止恶意流量进入网络，从而减少DNS污染的风险。
5. 使用VPN：使用VPN可以帮助您隐藏真实IP地址，保护您的网络连接免受DNS污染等网络攻击。

**Activity和Application的区别？**

**有什么方式在子线程更新UI？**

**了解哪些设计模式？**

1. 工厂模式：在创建对象时使用工厂模式，以便在不暴露对象创建逻辑的情况下，统一管理对象的创建。
2. 单例模式：使用单例模式可以确保一个类只有一个实例，并且提供全局访问点以访问该实例。
3. 适配器模式：使用适配器模式可以将不兼容的接口转换为可兼容的接口，以满足客户端的需求。
4. 观察者模式：使用观察者模式可以在对象之间建立一对多的依赖关系，以便在对象状态发生变化时通知依赖对象。
5. 装饰器模式：使用装饰器模式可以在不修改现有代码的情况下，动态地添加或修改对象的功能。
6. 代理模式：使用代理模式可以在访问对象时添加额外的控制层，以提供更加严格的访问控制或者延迟加载等功能。
7. 建造者模式：使用建造者模式可以将一个复杂对象的构建过程分解为多个简单对象的构建过程，以简化对象的创建。
8. 策略模式：使用策略模式可以定义一系列算法，并将每个算法封装起来，以便在运行时可以动态地切换算法。

**说一下单例模式的几个写法？**

1. 饿汉式单例模式：

```java
public class Singleton {
    private static Singleton instance = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() {
        return instance;
    }
}
```

这种写法在类加载时就已经创建了单例对象，因此线程安全。但是如果该类的创建和初始化比较耗时，会导致应用程序启动缓慢。

2. 懒汉式单例模式：

```java
public class Singleton {
    private static Singleton instance = null;
    private Singleton() {}
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

这种写法是在第一次调用`getInstance()`方法时才创建单例对象，因此称为懒汉式。由于是在方法中进行判断和创建，因此存在线程安全问题。需要在方法上添加`synchronized`关键字，以保证线程安全，但是会影响性能。

3. 双重检查锁定单例模式：

```java
public class Singleton {
    private static volatile Singleton instance = null;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

这种写法是在懒汉式单例模式的基础上，增加了双重检查锁定，以提高性能。其中，`volatile`关键字可以保证线程可见性。这种写法是比较常用的单例模式写法，可以保证线程安全且具有良好的性能。

4. 静态内部类单例模式：

```java
public class Singleton {
    private Singleton() {}
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

这种写法使用了静态内部类的特性，即只有在使用时才会被加载。这种写法既可以保证线程安全，也可以保证懒加载，并且可以避免使用`synchronized`关键字带来的性能问题。

**观察者模式的设计？**

以下是观察者模式的基本设计：

1. 定义一个抽象主题类（Subject），它包含了一个观察者列表和一些用于增加、删除和通知观察者的方法。
2. 定义一个抽象观察者类（Observer），它包含了一个用于接收主题状态变化通知的方法。
3. 定义一个具体主题类（ConcreteSubject），它实现了抽象主题类中的方法，并维护了一个状态变量，当状态变化时通知所有观察者。
4. 定义一个具体观察者类（ConcreteObserver），它实现了抽象观察者类中的方法，并在接收到主题状态变化通知时更新自己的状态。

在具体实现中，可以采用以下方式：

1. 在抽象主题类中，使用一个列表来存储所有的观察者，并提供一个注册和取消注册观察者的方法，以及一个通知所有观察者的方法。
2. 在抽象观察者类中，定义一个用于接收主题状态变化通知的抽象方法。
3. 在具体主题类中，维护一个状态变量，并在状态变化时调用通知所有观察者的方法，以便将状态变化通知给所有的观察者。
4. 在具体观察者类中，实现接收主题状态变化通知的方法，并在该方法中更新自己的状态。

观察者模式的优点是将观察者和主题解耦，使得它们可以独立地变化。这种模式可以提高对象之间的灵活性和可重用性。同时，观察者模式也有一些缺点，例如在使用过程中可能会导致对象之间的循环依赖，以及可能会导致性能问题。

**说说仓库管理的git？**

Git是一种分布式版本控制系统，它可以用于管理代码的版本、合并代码、记录代码变更等操作。在软件开发中，Git常常被用于协作开发、代码审查、版本回滚等场景。以下是Git在仓库管理中的一些常见操作：

1. 创建仓库

可以使用`git init`命令在本地创建一个新的Git仓库，也可以在GitHub等代码托管平台上创建远程仓库。在创建仓库时，需要指定仓库名称、描述、访问权限等参数。

2. 添加文件

可以使用`git add`命令将新文件添加到Git仓库中。Git会跟踪文件的变化，并记录每个文件的版本历史。在添加文件时，可以指定文件名、目录名、通配符等参数。

3. 提交变更

可以使用`git commit`命令提交变更到Git仓库中。提交变更时，需要添加变更说明、作者等元数据信息。在提交变更时，Git会生成一个唯一的版本号（也称为commit ID），以标识该版本的变更历史。

4. 分支管理

可以使用`git branch`命令创建、删除、合并分支。分支是Git中一个重要的概念，它可以用于并行开发、测试新功能、修复Bug等操作。Git支持多分支管理，可以在不同的分支上开发不同的功能，并在需要时将它们合并到主分支中。

5. 远程同步

可以使用`git push`命令将本地变更推送到远程仓库中，也可以使用`git pull`命令将远程仓库中的变更拉取到本地。在协作开发、团队合作等场景中，远程同步是非常重要的操作。

6. 版本回退

可以使用`git reset`命令回退到之前的某个版本，或者使用`git revert`命令撤销某次提交。版本回退可以用于撤销错误的变更、恢复到之前的某个状态、修复Bug等操作。

以上是Git在仓库管理中的一些常见操作。Git具有分布式、高效、灵活等优点，被广泛应用于软件开发和代码管理中。

**技术派项目遇到过什么问题？**

1. 前后端分离的架构设计：技术派项目采用了前后端分离的架构，需要前后端开发人员密切协作，同时需要考虑如何实现前后端数据交互、跨域访问、权限管理等问题。
2. 用户登录和权限管理：技术派项目需要实现用户登录、权限管理等功能，需要考虑用户安全性、身份验证、权限控制等问题。

**有哪些实践自己所学的知识？**

**参加过哪些比赛？**

**描述一下树的遍历？**

在树上，有两种常见的遍历方式：深度优先遍历和广度优先遍历。

1. 深度优先遍历

深度优先遍历是一种先访问子节点再访问兄弟节点的遍历方式。常见的深度优先遍历方式有三种：前序遍历、中序遍历和后序遍历。

前序遍历：先访问当前节点，然后递归访问左子树和右子树。

中序遍历：先递归访问左子树，然后访问当前节点，最后递归访问右子树。

后序遍历：先递归访问左子树和右子树，最后访问当前节点。

深度优先遍历一般使用递归实现，也可以使用栈来模拟递归实现。

2. 广度优先遍历

广度优先遍历是一种逐层遍历的方式，先访问当前节点的所有子节点，然后再访问所有子节点的子节点，以此类推。常见的广度优先遍历方式是层序遍历，即从根节点开始，逐层遍历树上的所有节点。

广度优先遍历一般使用队列实现，从根节点开始入队，依次取出队列中的节点，并将它们的子节点入队，直到队列为空。

**关于技术和其它平时怎么学习的？**