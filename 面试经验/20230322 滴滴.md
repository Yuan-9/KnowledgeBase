# 20230322 滴滴一面

**算法题：二叉搜索树中第k小元素**

**了解过中序遍历非递归写法吗？**

可以使用一个栈来实现二叉树的中序遍历。以下是一个简单的实现过程：

1. 初始化一个空栈。

2. 将当前节点设置为根节点。

3. 当栈不为空或当前节点不为空时，执行以下操作： 

	a. 如果当前节点不为空，将其压入栈中，并将当前节点设置为其左子节点。 

	b. 如果当前节点为空，从栈中弹出一个节点，访问它，然后将当前节点设置为该节点的右子节点。

**进程和线程的区别？**

进程是程序在操作系统中的一次执行过程，是系统资源分配和调度的基本单位，它包括了程序代码、数据、堆栈等信息，具有独立的内存空间和系统资源，各个进程之间相互独立，互不干扰。

线程是进程中的一个执行单元，是系统调度的最小单位，一个进程可以包含多个线程，共享进程的资源，但是每个线程都有自己的栈空间和程序计数器。线程之间的切换比进程之间的切换更快，因为它们共享了进程的内存空间和系统资源，而不需要像进程那样进行资源的重新分配和初始化。

总的来说，进程和线程都是并发执行的基本单位，但是进程之间相互独立，资源隔离，线程则共享进程的资源，切换更快，但是需要遵守一定的线程同步和互斥规则，以避免数据竞争和死锁等问题。

**线程之间同步的方式？**

在操作系统中，线程之间同步的方式主要包括以下几种：

1. 互斥锁：互斥锁是一种同步原语，它可以确保在同一时间只有一个线程可以访问共享资源，其他线程需要等待当前线程释放锁之后才能访问。互斥锁可以通过操作系统提供的系统调用来实现，例如在Linux系统中可以使用pthread_mutex_t类型的变量和相应的加锁和解锁函数来实现。
2. 信号量：信号量是一种同步原语，它可以用来控制对共享资源的访问数量。每个线程在访问共享资源之前需要获取一个信号量，如果当前信号量的计数器为0，则需要等待其他线程释放信号量之后才能获取；当访问共享资源结束后，线程需要释放信号量，让其他线程可以继续访问。在Linux系统中可以使用sem_t类型的变量和相应的P操作和V操作函数来实现。
3. 条件变量：条件变量是一种同步原语，它可以用来协调多个线程之间的操作，例如线程的等待和唤醒。每个条件变量与一个互斥锁相关联，线程可以通过条件变量等待某个条件的发生，并在条件满足时被唤醒。在Linux系统中可以使用pthread_cond_t类型的变量和相应的等待和唤醒函数来实现。
4. 屏障：屏障是一种同步原语，它可以用来协调多个线程在某个点上的同步。线程在执行到屏障之前需要等待其他线程到达同一个屏障点，然后才能一起继续执行后续的操作。在Linux系统中可以使用pthread_barrier_t类型的变量和相应的初始化、等待和销毁函数来实现。

**介绍一下Linux的进程内存模型是什么样的？**

Linux的进程内存模型是基于虚拟内存的，每个进程都有自己的虚拟地址空间。虚拟内存是一种抽象的概念，它将进程使用的内存分为若干个大小相等的页面（page），每个页面的大小通常是4KB或者8KB。

进程的虚拟地址空间包括以下几个区域：

1. 代码区：用来存放可执行代码的区域，通常是只读的。
2. 数据区：用来存放全局变量和静态变量等数据的区域，通常是可读写的。
3. 堆区：用来存放动态分配的内存，堆区的大小可以动态调整。
4. 栈区：用来存放函数调用时的局部变量和函数参数等数据，栈区的大小也可以动态调整。
5. 共享库区：用来存放共享库的区域，多个进程可以共享同一个共享库，减少内存的使用。

每个进程的虚拟地址空间是独立的，但是它们都映射到相同的物理内存上。当进程访问虚拟地址时，操作系统会根据映射关系将虚拟地址转换为物理地址，然后进行实际的读写操作。如果物理内存不足，则操作系统会将一部分内存写入到磁盘交换空间中，以释放物理内存，等需要时再从磁盘中读取回来。

总的来说，Linux的进程内存模型是基于虚拟内存的，它能够为每个进程提供独立的地址空间和保护机制，使得进程之间相互隔离，同时也能够有效地管理和优化内存的使用。

**介绍一下HTTP请求的几种方法？**

1. GET方法：GET方法用于从服务器获取资源，请求的参数以查询字符串的形式附加在URL后面，例如：http://example.com/?name=value。GET方法的请求是幂等的，即对同一URL的多次请求结果相同，不会对服务器端的资源产生副作用。
2. POST方法：POST方法用于向服务器提交数据，请求的参数以表单数据的形式发送，例如：name=value&age=18。POST方法的请求不是幂等的，即对同一URL的多次请求可能会对服务器端的资源产生副作用，例如添加一条记录到数据库中。
3. PUT方法：PUT方法用于向服务器上传文件或者更新资源，请求的参数以请求体的形式发送，例如上传一个文件。PUT方法的请求是幂等的，即多次发送同一个请求不会对服务器端的资源产生影响。
4. DELETE方法：DELETE方法用于删除服务器上的资源，请求的参数以URL的形式发送，例如：http://example.com/delete/1。DELETE方法的请求是幂等的，即多次发送同一个请求的结果相同，不会对服务器端的资源产生影响。
5. HEAD方法：HEAD方法与GET方法类似，但是不返回实体的主体部分，只返回响应头信息，用于获取资源的元数据信息。
6. OPTIONS方法：OPTIONS方法用于获取服务器支持的HTTP请求方法和资源支持的MIME类型等信息。
7. TRACE方法：TRACE方法用于对客户端和服务器之间的请求和响应进行追踪和诊断。

**GET和POST的区别？**

1. 参数传递方式：GET方法通过URL中的查询字符串来传递参数，而POST方法通过请求体来传递参数。
2. 安全性：GET方法的请求参数可以被缓存、历史记录和浏览器地址栏等记录，可能会造成安全隐患，例如密码等敏感信息会暴露在URL中。而POST方法的请求参数不会被记录在历史记录和浏览器地址栏中，相对更加安全。
3. 请求数据大小：GET方法传递参数的大小有限制，不同的浏览器和服务器实现有不同的限制，一般在2KB到8KB之间。而POST方法传递参数的大小理论上没有限制，但是实际上也会受到服务器和网络带宽的限制。
4. 幂等性：GET方法的请求是幂等的，即对同一URL的多次请求结果相同，不会对服务器端的资源产生副作用。而POST方法的请求不是幂等的，即对同一URL的多次请求可能会对服务器端的资源产生副作用，例如添加一条记录到数据库中。

**使用用户名密码登录时使用GET发送到服务器端还是POST发送到服务器端？**

使用用户名密码登录时应该使用POST方法发送到服务器端，而不是GET方法。使用POST方法相对更加安全，可靠，可以传输较大的数据，更适合用于用户名密码登录等场景。而GET方法则适用于获取资源、查询操作等场景。

**用户登录后是用什么方式保持他的登录状态的？**

1. Session：服务器可以为每个用户创建一个唯一的Session ID，并将这个ID存储在Session中。在用户登录后，服务器会将这个Session ID发送到客户端，保存在Cookie中。在之后的每个请求中，客户端会将这个Session ID作为参数发送到服务器端，服务器通过这个ID可以识别当前请求对应的用户，并检查用户是否已经登录。
2. Token：服务器可以为每个用户生成一个唯一的Token，将这个Token返回给客户端，并要求客户端在之后的请求中携带这个Token。客户端在之后的每个请求中将Token作为请求头或者请求参数发送到服务器端，服务器可以通过这个Token识别当前请求对应的用户，并检查用户是否已经登录。
3. JWT：JWT（JSON Web Token）是一种基于Token的身份验证机制，它将用户的信息以JSON格式编码，并使用签名算法进行加密。服务器在用户登录成功后，生成一个JWT并将其发送到客户端，客户端在之后的请求中携带这个JWT，服务器通过验证JWT的签名和有效期等信息来验证用户身份。

**如何设置登录状态维持的时间？**

1. Session的过期时间：服务器可以设置Session的过期时间，当用户登录成功后，服务器为用户创建一个Session，并将Session ID保存在Cookie中，同时在服务器端创建一个Session对象，其中包含用户的登录状态等信息。当用户发起下一个请求时，服务器通过Session ID找到对应的Session对象，从中读取用户的登录状态。当Session过期时，服务器会将Session对象从内存或者硬盘中删除，用户的登录状态也就失效了。一般来说，Session的过期时间可以在服务器端的配置文件中设置，默认是30分钟或者1小时。
2. Token的有效期：服务器为用户生成的Token也可以设置有效期，当Token过期时，客户端需要重新向服务器申请新的Token。一般来说，Token的有效期可以通过服务器端的配置文件或者接口返回的数据中设置。
3. JWT的有效期：JWT的有效期也可以设置，服务器在生成JWT时，可以设置过期时间，即“exp”字段的值，表示这个JWT的有效期截止时间。当客户端发送包含JWT的请求时，服务器会验证JWT的签名和有效期，如果过期则拒绝请求。一般来说，JWT的有效期可以根据业务需要进行设置，一般为几分钟到几小时不等。

**介绍一下MySQL的存储引擎？他们有什么区别？**

下面是MySQL常见的存储引擎以及它们的区别：

1. InnoDB引擎：InnoDB是MySQL的默认存储引擎，支持事务和行级锁定。InnoDB是一个ACID兼容的存储引擎，可以保证数据的一致性和持久性。InnoDB还支持外键约束、热备份和崩溃恢复等功能，适合于大型事务处理和高并发读写的应用场景。
2. MyISAM引擎：MyISAM是MySQL的另一种常用存储引擎，不支持事务和行级锁定。MyISAM适合于读写比例较低的应用场景，例如查询较多的数据仓库、日志系统等。MyISAM的优点是快速的读取速度和空间占用较小，但是对于并发写入和更新操作，MyISAM的性能较差。
3. Memory引擎：Memory存储引擎将数据保存在内存中，可以快速读写。Memory存储引擎不支持事务和行级锁定，适合于临时数据的存储，例如会话信息、缓存数据等。由于数据存储在内存中，因此重启MySQL服务器或者崩溃后，数据将会丢失。
4. Archive引擎：Archive存储引擎可以将数据高效地压缩和存储，适合于存储历史数据和归档数据等。Archive存储引擎不支持索引、事务和行级锁定，适合于大批量的插入操作和只读操作，但是对于查询和更新操作的性能较差。
5. CSV引擎：CSV存储引擎可以将数据保存为CSV格式文件，适合于需要导出数据的应用场景。CSV存储引擎不支持索引、事务和行级锁定，适合于读写比例较低的应用场景。

总的来说，MySQL的不同存储引擎各有特点，应根据实际情况选择合适的存储引擎。一般来说，InnoDB存储引擎适合于大型事务处理和高并发读写的应用场景，MyISAM存储引擎适合于读写比例较低的应用场景，Memory存储引擎适合于临时数据的存储，Archive存储引擎适合于存储历史数据和归档数据等。

**了解过MySQL的索引是如何实现的吗？它内部采用的数据结构是怎样的？**

MySQL的索引是通过B-Tree数据结构来实现的，它是一种多路搜索树，每个节点可以包含多个键值和子节点。B-Tree的特点是高效的插入、删除和查找操作，同时支持范围查询。

MySQL的InnoDB存储引擎中的B-Tree索引采用了聚簇索引和辅助索引两种类型：

1. 聚簇索引：聚簇索引是指将数据和索引存储在同一个B-Tree中的索引类型。在InnoDB中，每张表都必须有一个主键，主键就是聚簇索引。聚簇索引的特点是可以将相邻的数据存储在一起，因此可以提高范围查询的性能。
2. 辅助索引：辅助索引是指除主键以外的其他索引。在InnoDB中，辅助索引存储的是行的主键值，而不是行本身的数据。当查询命中辅助索引时，需要再根据主键值到聚簇索引中查找对应的行数据，因此查询辅助索引需要多一次查找操作。

除了B-Tree索引，MySQL还支持哈希索引和全文索引等类型的索引，不过这些索引的使用场景比较有限。哈希索引适用于等值查询，不支持范围查询和排序操作。全文索引适用于文本检索，支持全文检索和分词等操作，但是它的性能和空间占用都较高。

**简单说一下B树的数据结构是怎么样的？**

B树是一种多路搜索树，它的数据结构具有以下特点：

1. 树的所有节点都存储数据或键值，并且每个节点包含多个键值和子节点。
2. 每个节点的键值都按照升序排列，并且相邻键值之间有一定的大小范围。
3. 所有叶子节点都位于同一层，称为B树的深度或者高度。
4. B树的根节点可以有多个子节点，称为分支节点，而非叶子节点。
5. B树的节点分为内部节点和叶子节点两种类型，内部节点用来存储键值和指向子节点的指针，而叶子节点用来存储数据或者键值和数据的指针。
6. B树的节点通常被存储在磁盘上，因此每个节点的大小通常是固定的，并且可以被预读到内存中以提高访问性能。

B树的特点是支持高效的插入、删除和查找操作，并且支持范围查询。B树的平衡性是通过节点分裂和合并来保证的，当节点的键值超出预设范围时，就需要将节点分裂成两个节点，或者将两个相邻的节点合并成一个节点。B树的深度通常比较小，因此查询操作的时间复杂度为O(log n)，适用于高效存储和检索大量数据的场景。

**B+树的数据结构是什么样的？**

B+树是一种多路搜索树，它是B树的一种变体。与B树不同的是，B+树的非叶子节点不存储数据，只存储键值和子节点的指针。所有的数据都存储在叶子节点上，叶子节点之间通过指针相互连接，形成一个链表。B+树的数据结构具有以下特点：

1. 所有的数据都存储在叶子节点上，因此叶子节点数量比内部节点数量多一个。
2. 所有的叶子节点都按照键值大小顺序连接成一个有序链表，可以支持范围查询。
3. B+树的内部节点仅仅用于索引，不存储数据，因此可以存储更多的键值和子节点指针。
4. B+树的内部节点存储的键值可以重复，因此查找操作可以快速定位到数据所在的叶子节点。
5. B+树的叶子节点通常比较大，因此每次磁盘I/O能够读取的数据更多，可以提高访问性能。

B+树的特点是支持高效的插入、删除和查找操作，并且支持范围查询和排序。B+树的平衡性是通过节点分裂和合并来保证的，当节点的键值超出预设范围时，就需要将节点分裂成两个节点，或者将两个相邻的节点合并成一个节点。B+树的深度通常比较小，因此查询操作的时间复杂度为O(log n)，适用于高效存储和检索大量数据的场景。B+树常用于数据库索引、文件系统索引等场景。

**如果MySQL中数据量大的时候，如何解决搜索效率变低的问题？**

1. 添加索引：索引是提高搜索效率的常用方式，可以通过索引来快速定位数据。在MySQL中，可以为表的列添加索引，加速搜索和排序操作。但是索引也会占用额外的存储空间，并且会影响插入、删除和更新操作的性能，因此需要权衡索引的使用。
2. 分库分表：当单个MySQL实例无法承载大量数据时，可以考虑将数据分散到多个实例中。分库分表可以提高搜索效率，并且可以提高系统的可伸缩性和容错性。但是分库分表需要额外的开发和运维成本，并且可能会导致一些查询操作变得更加复杂。
3. 使用缓存：当数据量大时，可以考虑将常用数据缓存到内存中，减少磁盘I/O操作，提高搜索效率。常用的缓存方案包括Memcached和Redis等。但是缓存也需要占用额外的内存资源，并且需要考虑缓存数据一致性和更新等问题。
4. 优化查询语句：可以通过优化查询语句来提高搜索效率，比如合理地使用索引、避免使用子查询、尽量减少跨表查询等。可以使用MySQL提供的查询分析器来查找慢查询语句，并进行优化。
5. 使用分布式搜索引擎：当MySQL无法满足搜索需求时，可以考虑使用分布式搜索引擎，比如Elasticsearch、Solr等。分布式搜索引擎可以快速地处理大规模数据，并且可以提供更加灵活的搜索方式和更好的搜索结果。但是分布式搜索引擎也需要额外的开发和运维成本，并且需要考虑数据同步和一致性等问题。

**介绍经典的排序算法有哪些？**

1. 冒泡排序（Bubble Sort）：将相邻的元素逐个比较，每次把最大或最小的元素放到最后面或最前面。
2. 选择排序（Selection Sort）：每次从未排序的序列中选出最小的元素，放到已排序的序列末尾。
3. 插入排序（Insertion Sort）：将未排序的元素插入到已排序的序列中，插入时从后往前比较，找到插入位置。
4. 希尔排序（Shell Sort）：插入排序的改进版，先将整个序列分成若干个子序列，对子序列分别进行插入排序，再逐渐减小子序列的长度，直到整个序列变为有序。
5. 归并排序（Merge Sort）：将序列分成若干个子序列，对子序列进行排序，然后合并子序列得到最终的有序序列。
6. 快速排序（Quick Sort）：选择一个基准元素，将序列分成两个子序列，小于基准元素的放在左边，大于基准元素的放在右边，再对子序列进行快速排序，最终得到有序序列。
7. 堆排序（Heap Sort）：将序列看成一个完全二叉树，将其转化为大根堆或小根堆，然后将根节点与最后一个叶子节点交换，再将交换后的子树重新调整为大根堆或小根堆，重复此过程，最终得到有序序列。

**快速排序的时间复杂度？**

快速排序的平均时间复杂度为O(n log n)，最坏时间复杂度为O(n^2)。在最坏情况下，快速排序的时间复杂度会退化为冒泡排序，即每次选择的基准元素都是序列中的最大或最小元素，导致递归深度过大，效率变低。但是在实际情况下，快速排序的最坏情况发生的概率很小，而且可以通过随机选取基准元素、三数取中法等方式来减少最坏情况的发生。

**冒泡排序是否是稳定的排序？**

冒泡排序是一种稳定的排序算法。在冒泡排序中，当比较的两个元素相等时，不会进行交换操作，因此相同元素的相对位置不会改变。

**排序的稳定性是什么意思？**

排序的稳定性指的是，在排序过程中，如果有两个元素值相等的元素，排序前后它们的相对位置不发生改变。

**技术派在链接数据库的时候采用的是什么方式？**

项目使用了MyBatis框架，使用MyBatis提供的方式来连接MySQL数据库。MyBatis框架通常采用以下方式来连接数据库：

1. 配置数据源：MyBatis框架需要知道要连接的数据库的地址、用户名和密码等信息，可以通过在配置文件中定义数据源来配置这些信息。MyBatis支持多种数据源，包括JDBC、C3P0、DBCP等。
2. 配置映射文件：MyBatis的映射文件是一种XML格式的文件，用于描述Java对象和数据库表之间的映射关系。在映射文件中，需要定义SQL语句、参数映射、返回结果映射等信息。
3. 创建SqlSessionFactory：SqlSessionFactory是MyBatis的核心接口之一，用于创建SqlSession对象。在创建SqlSessionFactory时，需要传入数据源和映射文件等参数。
4. 创建SqlSession：SqlSession是MyBatis的另一个核心接口，用于执行SQL语句、提交事务等操作。在使用SqlSession前，需要先通过SqlSessionFactory来创建SqlSession对象。
5. 执行SQL语句：在SqlSession中，可以使用Mapper接口和SQL语句的ID来执行SQL语句，获取结果等操作。在执行SQL语句前，需要通过Mapper接口和映射文件来定义SQL语句和参数映射等信息。

总的来说，MyBatis框架提供了一套基于XML和注解的方式来连接MySQL数据库，并且可以方便地进行SQL操作和事务管理等操作。通过配置数据源和映射文件，可以实现Java对象和数据库表之间的映射，从而方便地进行数据操作。

**它是服务器端每接受一个请求就链接一次数据库吗？**

在一个高并发的Web应用中，服务器端每接收一个请求就链接一次数据库是非常低效和不可取的。这样做会导致服务器的数据库连接数过高，从而降低服务器的性能和稳定性。因此，通常采用连接池的方式来优化数据库连接的使用。

连接池是一种管理数据库连接的技术，它会在启动应用时预先创建一定数量的数据库连接，并将这些连接保存在一个池中。当服务器需要连接数据库时，它会从连接池中获取一个空闲的数据库连接，并在使用完毕后将连接归还给连接池。这样可以避免频繁地创建和销毁数据库连接，从而提高应用的性能和稳定性。

在使用MyBatis框架时，通常会使用连接池来管理数据库连接。MyBatis支持多种连接池实现，包括C3P0、DBCP、HikariCP等。这些连接池都可以通过配置文件来设置最大连接数、最小连接数、连接超时时间等参数，从而实现更加高效和可靠的数据库连接管理。因此，服务器端并不是每接收一个请求就链接一次数据库，而是通过连接池来管理数据库连接的使用。

**由于网络问题，与数据库的链接可能会断开，如何处理这种问题？**

1. 重试机制：如果数据库连接断开，可以在代码中实现重试机制，重新尝试连接数据库，直到连接成功或者达到最大尝试次数。这种方式可以保证在网络状况不稳定的情况下，仍能够保持与数据库的连接，但是需要注意不能无限制地进行重试，否则可能会对服务器和数据库造成影响。
2. 心跳检测：可以通过定时发送心跳包的方式来检测数据库的连接状态。如果数据库连接断开，可以及时发现并重新连接。这种方式可以及时发现数据库连接断开的情况，但是需要注意心跳包的频率不能过高，否则可能会对服务器和数据库造成额外的负担。
3. 连接池的自动重连：连接池通常会提供自动重连的功能，可以在数据库连接断开后自动尝试重新连接，从而保证数据库连接的可用性。这种方式可以减少代码的编写量，但是需要注意不能过度依赖连接池的自动重连功能，否则可能会导致性能问题。